#version 460


layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// 1. 将格式改为 rgba32f
layout (binding = 0, rgba32f) uniform writeonly image2D outputImage;

const vec3 sphere_center = vec3(0.0, 0.0, 2.0);
const float sphere_radius = 1.0;

bool intersect_sphere(in vec3 ray_origin, in vec3 ray_direction, out float t_out) {
    vec3 oc = ray_origin - sphere_center;
    float a = dot(ray_direction, ray_direction);
    float b = 2.0 * dot(oc, ray_direction);
    float c = dot(oc, oc) - sphere_radius * sphere_radius;
    float discriminant = b * b - 4.0 * a * c;
    
    if (discriminant < 0.0) {
        return false;
    } else {
        t_out = (-b - sqrt(discriminant)) / (2.0 * a);
        return t_out > 0.0;
    }
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 image_size = vec2(imageSize(outputImage));
    vec2 normalized_coords = (vec2(pixel_coords) / (image_size - 1.0)) * 2.0 - 1.0;
    float aspect_ratio = image_size.x / image_size.y;
    
    vec3 ray_direction = normalize(vec3(normalized_coords.x * aspect_ratio, normalized_coords.y, 1.0));
    vec3 ray_origin = vec3(0.0, 0.0, -0.0);
    
    float t_hit;
    
    if (intersect_sphere(ray_origin, ray_direction, t_hit)) {
        vec3 hit_position = ray_origin + ray_direction * t_hit;
        
        // 2. 直接存储未转换的法线向量
        vec3 normal = normalize(hit_position );
        
        imageStore(outputImage, pixel_coords, vec4(normal, 1.0));
    } else {
        imageStore(outputImage, pixel_coords, vec4(0.5, 0.56, 0.7, 1.0));
    }
}